[3 程序的机器级表示](#9382-1576590313165)

[3.2 程序编码](#7996-1576590176710)

[3.2.1 机器级代码](#4025-1576590181478)

[3.2.2 代码示例](#5946-1576590187790)

[3.2.3 关于格式的注解](#4040-1576589938263)

[3.3 数据格式](#8289-1576589935287)

[3.4 访问信息](#9128-1576589935287)

[3.4.1 操作数指示符](#3630-1576589935287)

[3.4.2 数据传送指令](#4261-1576589935287)

[3.4.3 数据传送示例](#9736-1576664873517)

[3.4.4 压入和弹出栈数据](#2790-1576589935287)

[3.5 算术和逻辑操作](#7384-1576589935287)

[3.5.1 加载有效地址](#6096-1576589935287)

[3.5.2 一元和二元操作](#6557-1576589935287)

[3.5.3 移位操作](#1995-1576589935287)

[3.5.4 特殊的算术操作](#5311-1576589935287)

[3.6 控制](#2936-1576589935287)

[3.6.1 条件码](#3535-1576589935287)

[3.6.2 访问条件码](#6773-1576589935287)

[3.6.3 跳转指令](#7555-1577287353775)

[3.6.4 跳转指令的编码](#3484-1577361366314)

[3.6.5 用条件控制来实现条件分支](#1153-1576589935287)

[3.6.6 用条件传送来实现条件分支](#2780-1577364771625)

[3.6.7 循环](#3045-1576589935287)

[3.6.8 switch语句](#9080-1576589952966)

[3.7 过程](#5044-1576589957827)

[3.7.1 运行时栈](#7656-1576589957827)

[3.7.2 转移控制](#9691-1576589957827)

[3.7.3 数据传送](#9099-1576589957827)

[3.7.4 栈上的局部存储](#1026-1576589957827)

[3.7.5 寄存器中的局部存储空间](#3539-1576589957827)

[3.7.6 递归过程](#6389-1576589957827)

[3.8 数组分配和访问](#7088-1576589957827)

[3.8.1 基本原则](#7320-1576590071125)

[3.8.2 指针运算](#5150-1576589957827)

[3.8.3 嵌套的数组](#2070-1576589957827)

[3.8.4 定长数组](#2442-1576589957827)

[3.8.5 变长数组](#1633-1576589957827)

[3.9 异质的数据结构](#8500-1576589957827)

[3.9.1 结构](#7894-1576589957827)

[3.9.2 联合](#1056-1576589957827)

[3.9.3 数据对齐](#3065-1576589957827)

[3.10 在机器级程序中将控制与数据结合起来](#8563-1576589957827)

[3.10.1 理解指针](#2271-1576590000934)

[3.10.2 应用:使用GDB调试器](#9592-1576590003192)

[3.10.3 内存越界引用和缓冲区溢出](#8837-1576590003192)

[3.10.4 对抗缓冲区溢出攻击](#8379-1576590003192)

[3.10.5 支持变长栈帧](#5328-1576590003192)

[3.11 浮点代码](#3298-1576590003192)

[3.11.1 浮点传送和转换操作](#4867-1576590003192)

[3.11.2 过程中的浮点代码](#3827-1576590003192)

[3.11.3 浮点运算操作](#9064-1576590003193)

[3.11.4 定义和使用浮点常数](#0092-1576590003193)

[3.11.5 在浮点代码中使用位级操作](#6584-1576590003193)

[3.11.6 浮点比较操作](#3341-1576590003193)

[3.11.7 对浮点代码的观察结论](#4060-1576590003193)

[3.12 小结](#8444-1576590003193)

# 3 程序的机器级表示

编译器基于编程语言的规则、操作系统的惯例、目标机器的指令集生成机器代码。

汇编代码是机器代码的一种形式，它是机器代码的文本表示。

高级代码可移植性好，而汇编代码与特定机器密切相关。

能够阅读汇编代码：

*   好处：可以理解编译器的优化能力，并分析代码中隐含的低效率

*   条件：了解编译器将高级语言转换为机器代码的转换方式。

精通细节很重要，是理解更深和更基本概念的先决条件。要认真研究示例、完成练习。

32位机器可以使用约 4GB 的随机访问存储器，64位机器可以使用 256TB(2^48) 的内存空间(这里说的是主存)。

## 3.2 程序编码

汇编器产生的目标代码是机器代码的一种形式，它包含二进制形式表示的所有指令，但还没有填入全局值的地址。

### 3.2.1 机器级代码

影响机器级程序的两种抽象：

*   指令集架构：定义了处理器状态、指令的格式、指令对状态的影响。
*   虚拟地址：机器代码将内存看成一个按字节寻址的数组。

对机器代码可见的处理器状态：

1.  程序计数器
2.  整数寄存器文件：保存临时数据或重要的程序状态
3.  条件码寄存器：保存最近执行的算术或逻辑指令的状态信息。
4.  一组向量寄存器：保存一个或多个整数或浮点数值

C 语言中的数组和结构，在机器代码中用一组连续的字节来表示。

汇编代码不区分有符号数和无符号数，不区分指针的不同类型，不区分指针和整数。

一条机器指令只执行一个非常基本的操作。

### 3.2.2 代码示例

反汇编

使用反汇编器可以根据机器代码产生汇编代码。如：48 89 d3 → mov %rdx,%rbx

机器代码与反汇编表示的特性：

1.  x86-64 的指令长度范围为 1\~15 字节。常用指令和操作数少的指令所需字节少。
2.  从十六进制字节值到汇编指令，格式为：某个数字唯一地对应某个汇编指令，比如 mov 指令以 48 开头。
3.  指令结尾的 'q' 是大小指示符，大多数情况下可以省略。

从源程序转换来的可执行目标文件中，除了程序过程的代码，还包含启动和终止程序的代码，与操作系统交互的代码。

链接器的任务之一就是为函数调用找到匹配的函数的可执行代码的位置。

### 3.2.3 关于格式的注解

在汇编代码中，以 ‘.’ (点) 开头的行是指导汇编器和链接器工作的伪指令。

## 3.3 数据格式

字节：byte，8位；字：word，16位；双字：double words，32位；四字：quad words，64位。

对应的指令后缀：movb, movw, movl, movq。

这里说的都是整数，浮点数使用一组完全不同的指令和寄存器。

![image-20240607144537197](https://gitee.com/porlain/clouding/raw/master/202406071445309.png)

## 3.4 访问信息

一个 64 位 CPU 中包含一组 16 个存储 64 位值的通用目的寄存器，用来存储整数和指针。

16 个寄存器标号为 rax~rbp，r8~r15

16 个寄存器的低位部分都可以作为字节、字、双字、四字来单独访问。分别表示为 al, ax, eax, rax。

![image-20240607144551042](https://gitee.com/porlain/clouding/raw/master/202406071445257.png)

低位操作的规则：

1.  将寄存器作为目标位置时，生成字节和字的指令会保持剩下的字节不变
2.  生成双字的指令会把高位四字节置为 0.

16个寄存器的作用

1.  rax：返回值
2.  rsp：栈指针
3.  rdi, rsi, rdx, rcx, r8, r9：第 1 到第 6 个参数
4.  rbx, rbp, r12\~r15：被调用者保存
5.  r10, r11：调用者保存

### 3.4.1 操作数指示符

指令的操作数有三种类型：立即数，寄存器，内存引用

![image-20240607144600884](https://gitee.com/porlain/clouding/raw/master/202406071446023.png)

### 3.4.2 数据传送指令

mov类

mov 只会更新目的操作数指定的寄存器字节或内存位置。

mov 类是最简单的数据传送指令，mov 类有 5 种：

1.  movb, movw, movl：传送字节、字、双字
2.  movq：传送四字。如果源操作数是立即数，只能是双字，然后符号扩展到四字（假的四字）
3.  movabsq：传送绝对的四字。只能以立即数作为源操作数，以寄存器为目的。可以传送任意 64 位立即数。

movq 用来传送寄存器和内存引用中的四字，movabsq 用来传送四字的立即数

mov 类的源操作数和目的操作数不能同时为内存，即不能将值从内存复制到内存。

mov 指令中寄存器的大小必须与 mov 的后缀字符大小匹配。

```assembly
movb $-17, %al
```



![image-20240607144611510](https://gitee.com/porlain/clouding/raw/master/202406071446619.png)

movz类

movz 系列和 movs 系列可以把较小的源值复制到较大的目的，目的都是寄存器。

movz 将目的寄存器剩余字节做零扩展，movs 做符号扩展

movz类：movzbw, movzbl, movzbq, movzwl, movzwq（movzbw 即从字节复制到字，其他类似）

movs类：movsbw, movsbl, movsbq, movswl, movswq, movslq, cltq

*   cltq：没有操作数，将 eax 符号扩展到 rax，等价于 movslq %eax,%rax

![image-20240607144652199](https://gitee.com/porlain/clouding/raw/master/202406071446338.png)

### 3.4.3 数据传送示例

局部变量通常保存在寄存器中。

函数返回指令 ret 返回的值为寄存器 rax 中的值

强制类型转换是通过 mov 指令实现的。

当指针存在寄存器中时，a = \*p 的汇编指令为： mov (rdi), rax

### 3.4.4 压入和弹出栈数据

栈向下增长，栈顶的地址是栈中元素地址中最低的。栈指针 rsp 保存栈顶元素的地址。

出入栈指令：

*   pushq rax：压栈，栈指针减 8 并将 rax 中的值写入新的栈顶地址，等价于：subq \$8, (rsp) ; movq rax,(rsp)。
*   popq rax：出栈，栈指针加 8 并将出栈的值写入 rax 中，等价于：movq (rsp),rax ; add \$8,(rasp)

使用 mov 指令和标准的内存寻址方法可以访问栈内的任意位置，而非仅限于栈顶。

![image-20240607144703307](https://gitee.com/porlain/clouding/raw/master/202406071447405.png)

## 3.5 算术和逻辑操作

x86-64 的每个指令类都有对应四种不同大小数据的指令

算术和逻辑操作共有四组：

1.  加载有效地址

    1.  leaq S, D：将 S 的地址保存到 D 中，D 必须是寄存器
2.  一元操作

    1.  inc D: D+1
    2.  dec D: D-1
    3.  neg D：取负
    4.  not D：取补
3.  二元操作（加减乘，与或异或，没有除法）

    1.  add s, d: d=d+s
    2.  sub s, d: d=d-s
    3.  imul s, d: d=d\*s 乘
    4.  xor s, d: d=d^s 异或
    5.  or s, d: d=d|s 或
    6.  and s,d: d=d\&s 与
4.  移位

    1.  sal k,d: d=d<
    2.  shl k,d: d=d<
    3.  sar k,d: d=d<
    4.  shr k,d: d=d<

![image-20240607144713466](https://gitee.com/porlain/clouding/raw/master/202406071447606.png)

### 3.5.1 加载有效地址

leaq 实际上是 movq 指令的变形。操作是从内存读数据地址到寄存器。

leaq 在实际应用中常常不用来取地址，而用来计算加法和有限形式的乘法

```assembly
leaq 9(rdi, rsi, 4), rax;//x in rdi,y in rsi。此操作实际上等于将 x+4\*y+9 的结果存入 rax
```



### 3.5.2 一元和二元操作

一元操作中的操作数既是源又是目的。

二元操作中的第二个操作数既是源又是目的。

因为不能从内存到内存，因此当第二个操作数是内存地址时，要先从内存读出值，执行操作后再把结果写回去。

注意 sub s,d 是 d-s 而不是 s-d

### 3.5.3 移位操作

移位操作的移位量可以是一个立即数或放在单字节寄存器 cl 中。

当移位量大于目的数的长度时，只取移位量低字节中的值（小于目的数长度）来作为真实的移位量。

### 3.5.4 特殊的算术操作

两个 64 位数的乘积需要 128 位来表示，x86-64指令集可以有限的支持对 128 位数的操作，包括乘法和除法。

128 位数需要两个寄存器来存储，移动时也需要两个 movq 指令来移动。

这种情况对于有符号数和无符号数采用了不同的指令。

![image-20240607144740723](https://gitee.com/porlain/clouding/raw/master/202406071447833.png)

## 3.6 控制

条件语句、循环语句、分支语句都要求有条件的执行。

机器代码提供两种低级机制来实现有条件的行为：

1.  测试数据值，然后根据测试的结果来改变控制流或数据流
2.  使用 jump 指令进行跳转

### 3.6.1 条件码

条件码寄存器都是单个位的，是不同于整数寄存器的另一组寄存器。

条件码描述了最近的算术或逻辑操作的属性，可以通过检测这些寄存器来执行条件分支指令。

常用条件码：

1.  CF：进位标志。最近的操作使最高位产生了进位。可以用来检查无符号数的溢出
2.  ZF：零标志。最近的操作的结果为 0
3.  SF：符号标志。最近的操作的结果为负数。
4.  OF：溢出标志。最近的操作导致了补码溢出

除了 leaq 指令外，其余的所有算术和逻辑指令都会根据运算结果设置条件码。

此外还有两类特殊的指令，他们只设置条件码不更新目的寄存器：

*   cmp s1, s2：除了不更新目的寄存器外与 sub 指令的行为相同
*   test s1, s2：除了不更新目的寄存器外与 and 指令的行为相同

![image-20240607144752303](https://gitee.com/porlain/clouding/raw/master/202406071447426.png)

### 3.6.2 访问条件码

条件码一般不直接读取，常用的使用方法有 3 种：

1.  根据条件码的某种组合，使用 set 指令类将一个字节设置为 0 或 1。
2.  条件跳转到程序的某个其他部分
3.  有条件地传送数据

set 指令类

set 指令的目的操作数是低位单字节寄存器元素或一个字节的内存位置。set 会将该字节设置为 0 或 1

set 指令类的后缀指明了所考虑的条件码的组合，如 setl (set less) 表示“小于时设置”

![image-20240607144759634](https://gitee.com/porlain/clouding/raw/master/202406071447747.png)

注意到上图中，set 指令对于大于、小于的比较分为了有符号和无符号两类。

大多数时候，机器代码对无符号和有符号两种情况使用一样的指令。

使用不同指令来处理无符号和有符号操作的情况：

1.  不同的条件码组合：
2.  不同版本的右移：sar 和 shr
3.  不同的乘法和除法指令

汇编语言中数据本身不区分有符号和无符号，通过不同的指令来区分有符号操作和无符号操作。

注意在汇编代码中，8字节的操作数可能是 long，long long 或 指针

### 3.6.3 跳转指令

跳转指令的目的地由一个标号指明

```assembly
	jmp .L1 ;//跳转到 .L1 。在实际的跳转指令中，.L1 会直接编码为跳转目标的地址。 
	movq (rax),rdx 
.L1: 
	popq rdx
```

jmp 可以是直接跳转，即操作数为标号。也可以间接跳转，即操作数是寄存器或内存引用，这种情况下跳转到寄存器中存储的地址处。

跳转指令分为有条件跳转和无条件跳转，只有 jmp 是无条件跳转。有条件跳转都只能是直接跳转。

有条件跳转类似 set 指令系列，根据条件码寄存器的值来判断是否进行跳转。

![image-20240607144923929](https://gitee.com/porlain/clouding/raw/master/202406071449010.png)

### 3.6.4 跳转指令的编码

跳转指令的机器编码（就是纯粹数字表示的机器语言）有几种方式，其中两种如下：

*   PC 相对跳转：使用目标地址与跳转指令之后下一条指令的地址之间的差来编码。可以用 1、2 或 4 个字节来编码。
*   绝对地址编码：使用目标的绝对地址。用 4 个字节直接指出。

汇编器和链接器会自己选择适当的编码方式

### 3.6.5 用条件控制来实现条件分支

汇编代码层面的条件控制类似于 c 语言的 goto 语句。

汇编语言使用条件码和条件跳转来起到和 c 语言中 if 相似的作用

```c
// 'C 语言' 
if( x\<y ) { i++ } 
else { i-- } 
// '汇编' 
cmpq rsi,rdi 
jge .L2 incl rax; 
.L2: 
	decl rax;
```

### 3.6.6 用条件传送来实现条件分支

这种方法是不管判断的结果，执行if和else中的全部内容，然后等待判断结果的产生，将结果修改为判断正确的结果。

![image-20240607145040734](https://gitee.com/porlain/clouding/raw/master/202406071450858.png)

因为"流水线"技术(预测判断结果)，使用条件传送比使用条件控制的性能要好

![image-20240607145049147](https://gitee.com/porlain/clouding/raw/master/202406071450266.png)

不是所有的条件表达式都可以用条件传送来编译

```c
v = test-expr ? then-expr : else-expr; 
// 条件控制的方式编译 
if(!test-expr) 
    goto false; 
v = then-expr; 
goto done; 
false: 
v = else-expr 
done: 
// 条件传送的方式编译 
v = then-expr; 
ve = else-expr; 
t = test-expr; 
if(!t) v = ve;
```

条件传送会对结果都求值，条件控制会等待判断结果的产生，程序会产生阻塞的现象，无法充分利用流水线，但一般只有表达式比较简单的情况下，才会使用条件传送，复杂的计算会使用条件控制转移

### 3.6.7 循环

#### 1.do-while循环

```c
do 
    body-statement 
    while(test-expr);
```

```assembly
loop:
	body-statement 
	t = test-expr
	if(t)
		goto loop;
```

#### 2.while循环

while循环的底层貌似是do-while，基本可以翻译成do-while进行编译

```c
while(test-expr)
	body-statement 
```

翻译成机器代码的两种方式：

①.跳转到中间的方式(jump to middle)

```c
// 典型的while循环，先判断，后执行
	goto test;
loop:
	body-statement 
test:
	t = test-expr;
	if(t)
		goto loop;
```

②.grarded-do(do-while)

先执行一次，然后在判断

```c
// 这种方式类似于do-while循环
t = test-expr;
if(!t)
    goto done;
do
    body-statement 
    while(test-expr);
done:
```

```c
// goto代码
t = test-expr;
if(!t)
    goto done;
loop:
    body-statement 
    t = test-expr;
    if(t)
        goto loop
done:
```

#### 3.for循环

```c
for(init-expr;test-expr;update-expr)
	body-statement

// 类似于下面的while
init-expr;
while(test-expr){
    body-statement
    update-expr;
}
```

翻译方式：与while的翻译方法一致，都是有两种

```c
// 跳转到中间策略：
init-expr
goto test;
loop:
	body-statement
	update-expr;
test:
	t = test-expr;
	if(t)
        goto loop;
// guarded-do策略
	init-expr
	t = test-expr;
	if(t)
        goto done;
loop:
	body-statement
	update-expr;
	t = test-expr;
	if(t)
        goto loop;
done:
```

### 3.6.8 switch语句

switch使用跳转表，根据整数索引进行多重分支，类似于哈希表，用空间换时间，判断量较小时switch的表现优于if-else，但判断量较大时，性能不一定比if-else强，且会占用大量空间。

## 3.7 过程

过程类似于函数，struct，class等方式，封装代码并提供接口。

![image-20240607152244168](https://gitee.com/porlain/clouding/raw/master/202406071522294.png)

### 3.7.1 运行时栈

通过寄存器，函数最多传递6个参数，剩下的参数需要用到栈帧

![image-20240607154414418](https://gitee.com/porlain/clouding/raw/master/202406071544550.png)

### 3.7.2 转移控制

反汇编中位callq和retq，q代表是x86-64版本的调用和返回，而不是IA32的

![image-20240607154757193](https://gitee.com/porlain/clouding/raw/master/202406071547295.png)

### 3.7.3 数据传送

![image-20240607154936775](https://gitee.com/porlain/clouding/raw/master/202406071549898.png)

### 3.7.4 栈上的局部存储

当数据不能用寄存器存储时，会使用个内存进行存储，常见情况有：

1. 寄存器不能存放所有的本地数据
2. 对一个局部变量使用地址运算符&，必须为它产生一个地址
3. 数组或结构

### 3.7.5 寄存器中的局部存储空间

%rbx,%rbp,%r12~%r15为被调用者保存寄存器，P调用Q时，Q必须保存这些值，保证Q返回P时值不变。

除%rsp外，均为调用者保存寄存器，任何函数都能修改，P在调用Q前需要保存好数据

### 3.7.6 递归过程

每个过程调用在栈中都有自己的私有空间，因此多个未完成调用的局部变量不会互相影响。

## 3.8 数组分配和访问

C语言中数组的特点是可以产生指向数组中元素的指针，并对指针进行运算。

### 3.8.1 基本原则

### 3.8.2 指针运算

### 3.8.3 嵌套的数组

### 3.8.4 定长数组

### 3.8.5 变长数组

## 3.9 异质的数据结构

### 3.9.1 结构

### 3.9.2 联合

### 3.9.3 数据对齐

## 3.10 在机器级程序中将控制与数据结合起来

### 3.10.1 理解指针

### 3.10.2 应用:使用GDB调试器

### 3.10.3 内存越界引用和缓冲区溢出

### 3.10.4 对抗缓冲区溢出攻击

### 3.10.5 支持变长栈帧

## 3.11 浮点代码

### 3.11.1 浮点传送和转换操作

### 3.11.2 过程中的浮点代码

### 3.11.3 浮点运算操作

### 3.11.4 定义和使用浮点常数

### 3.11.5 在浮点代码中使用位级操作

### 3.11.6 浮点比较操作

### 3.11.7 对浮点代码的观察结论

## 3.12 小结
