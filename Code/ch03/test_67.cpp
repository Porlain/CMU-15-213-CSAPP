/*
 * @Create: Created by Porlain on 2024
 * @Author: Porlain szbj2023@163.com
 * @LastEditTime: 2024-05-13 17:05:47
 */

#include <stdio.h>
typedef struct
{
    long a[2];
    long *p;
} strA;

typedef struct
{
    long u[2];
    long q;
} strB;

strB process(strA s)
{
    strB r;
    r.u[0] = s.a[1];
    r.u[1] = s.a[0];
    r.q = *s.p;
    return r;
}

long eval(long x, long y, long z)
{
    strA s;
    s.a[0] = x;
    s.a[1] = y;
    s.p = &z;
    strB r = process(s);
    return r.u[0] + r.u[1] + r.q;
}

// long eval(long x，long y, long z)
// #x in %rdi, y in %rsi, z in %rdx
// eval:
// 	subq	$104, %rsp		#栈顶指针下移104（13*8）字节分配空间，13个八字节
// 	movq	%rdx, 24(%rsp)	#*(rsp + 24) = z，把z的值保存在偏移量为24的位置，即z存入栈指针开始的第4个八字节（24/8+1）
// 	leaq	24(%rsp), %rax	#%rax = rsp + 24 => &z，%rax保存z的指针,因为C代码s.p = &z;所以栈指针开始的第4个八字节存的s.p
// 	movq	%rdi, (%rsp)	#*rsp = x，x保存在偏移量为0的位置，即栈指针开始的第1个八字节,即s.a[0] = x
// 	movq	%rsi, 8(%rsp)	#*(rsp + 8) = y，y保存在栈指针开始的第2个八字节，即s.a[1] = y
// 	movq	%rax, 16(%rsp)	#*(rsp + 16) = z，栈指针开始的第3个八字节，即s.p = &z
// 	leaq	64(%rsp), %rdi	#栈指针开始的第9个八字节的开始地址，当做参数传递给后边的函数
// 	call	process			#有隐藏操作，分配八字节栈空间，存入返回地址，即下一行代码地址
// 	movq	72(%rsp), %rax	#%rax=*(rsp + 72)，这三行实现加法，即 %rax= r.u[1]
// 	addq	64(%rsp), %rax	#%rax=%rax+*(rsp +64)，即 %rax+=r.u[0]
// 	addq	80(%rsp), %rax	#%rax=%rax+*(rsp +80)，即 %rax+=r.q
// 	addq	$104, %rsp		#%rsp=%rsp+104,回收栈空间
// 	ret

// strB process(strA s)
// process:#因为有有隐藏操作，此时rsp又-8
// 	movq	%rdi, %rax		#把参数保存到%rax，第一个参数作为返回值，即要返回的结构体的开始地址（上面栈指针开始的第9个八字节的开始地址）
// 	movq	24(%rsp), %rdx	#%rdx=*(rsp + 24)，即%rdx=s.p
// 	movq	(%rdx), %rdx	#%rdx存放的s.p寻址得到存放的内容z，再存入%rdx，即%rdx=*(s.p)=z
// 	movq	16(%rsp), %rcx	#栈指针开始的第3个八字节的内容（原eval中的第2个，即s.a[1]），%rcx=*(rsp + 16),即 s.a[1]
// 	movq	%rcx, (%rdi)	#将s.a[1]，存入返回结构体的第1个八字节，r.u[0]=s.a[1]
// 	movq	8(%rsp), %rcx	#%rcx = *(rsp + 8)，即s.a[0]
// 	movq	%rcx, 8(%rdi)	#将s.a[0]，存入返回结构体的第2个八字节，r.u[1]=s.a[0]
// 	movg	%rdx, 16(%rdi)	#r.q=*(s.p)，存入返回结构体的第3个八字节
// 	#栈指针开始的第1个八字节，这里并没有使用，因为存的是调用后的返回地址
// 	ret

// A.
// 104  +------------------+
//      |                  |
//      |                  |
//      |                  |
//      |                  |
//      |                  |
//      |                  |
//      +------------------+
//      |                  |（第九个八字节）
//  64  +------------------+ <-- %rdi
//      |                  |
//      |                  |
//      |                  |
//      |                  |
//      |                  |
//      |                  |
//  32  +------------------+
//      |         z        |
//  24  +------------------+
//      |        &z        |					 （即s.p = &z）
//  16  +------------------+	
//      |         y        |					 （即s.a[1] = y）
//   8  +------------------+
//      |         x        |（第一个八字节）		（即s.a[0] = x）
//   0  +------------------+ <-- %rsp

// B.eva1 调用process时传递了什么值？

// 传递了一个相对于%rsp偏移量为64的指针,即栈指针开始的第9个八字节的开始地址。

// C.process的代码是如何访问结构参数s的元素的？

// 因为结构参数s存在栈空间里，所以用%rsp+偏移量来访问的。

// D.process的代码是如何设置结果结构r的字段的？

// r的空间是分配在栈空间里，所以也是%rsp+偏移量来设置的。

// E.完成eval的栈帧图，给出在从process返回后eval是如何访问结构r的元素的
// 104  +------------------+
//      |                  |
//      |                  |
//      |                  |
//      |                  |
//      |                  |
//      |                  |
//  88  +------------------+----
//      |        z         |	-								（即r.q）
//  80  +------------------+	-
//      |        x         |	--->(64到88)是返回结构体		 （即r.u[1]）
//  72  +------------------+	-								
//      |        y         |	-								（即r.u[0]）
//  64  +------------------+ <-- %rdi(eval pass in)
//      |                  |  \
//      |                  |   -- %rax(process pass out)
//      |                  |
//      |                  |
//      |                  |
//      |                  |
//  32  +------------------+
//      |         z        |
//  24  +------------------+----
//      |        &z        |   -
//  16  +------------------+	-
//      |         y        |	---->(0到24)是传入结构体
//   8  +------------------+	-
//      |         x        |	-
//   0  +------------------+ <-- %rsp in eval
//      |                  |
//  -8  +------------------+ <-- %rsp in process


// F.就如何传递作为函数参数的结构以及如何返回作为函数结果的结构值，你可以看出什么通用的原则？

// 结构体作为参数传入和返回时，都是以指针来传递。


