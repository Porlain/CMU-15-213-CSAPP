
// #long aframe(long n, long idx, long *q)
// #n in %rdi, idx in %rsi, q in %rdx
// aframe : 
// 	pushq	%rbp				#
// 	movq	%rsp, %rbp			#	
// 	subq	$16, %rsp        	Allocate space for i (%rsp = s1)
// 	leaq	30(,%rdi,8), %rax	#%rax=30+8n
// 	andq	$-16, %rax       	#%rax=%rax& (-1), 设置末4位为0
// 	#这里的-16的十六进制表示为0xfffffff0，之所以用& 就是为了求16的整数倍
// 	subq	%rax, %rsp       	Allocate space for array p (%rsp = s2)
// 	leaq	15(%rsp), %r8    	#%r8=%rsp+15
// 	andq	$-16, %r8        	set %r8 to &p[0]
// 	...

// andq $-16, %rax分为两种情况：（and -16解释为向下取整到16的倍数）
// a.当为偶数时，分成8n和30两部分，8n and -16得8n，30 and -16得16.
// b.当为奇数时，分成8(n-1)和38两部分，8(n-1) and -16得8(n-1)，38 and -16得32.
// leaq 15(%rsp), %r8加上偏置15（2^4-1）,第9行and -16，执行完这两行，就相当于向上取整到16的倍数。注意在练习题3.49中，andq $-16, %r8这句是通过两句汇编来实现的（先右移再左移，而本题是直接and -16）。

// 栈帧
// ----------     		 <-- 	%rbp  0
//    i
// -------8
// (未被使用的)
// ---------- s1    	 <-- 	%rbp-16
//     e1
// ----------

//     p
    
// ---------- p
//     e2
// ---------- s2

// A
// s1 = %rsp - 16
// s2 = s1 - ((30 + 8 * n) - (30 + 8 * n) mod 16)

// // B
// p = (s2 + 15) - ((s2 + 15) mop 16)

// C.确定使e1的值最小和最大的n和s1的值。

// s2可以写为s2 = s1 - (0xfffffff0 & (8n + 30))根据这个公式

// 当n是偶数的时候，我们可以把式子简化为s2 = s1 - (8 * n + 16)

// 当n是奇数的时候，我们可以把式子简化为 s2 = s1-[8(n-1)+32)]=s1 - (8 * n + 24)

// 大方向分为，当s2为16的倍数（这种情况p数组就直接从s2开始分配），和s2不为16的倍数（这种情况p数组还需要向地址增加方向滑动1-15个字节）。

// 1.因为e1和e2是用来滑动的，所以当e2为0，即s2为16的倍数时，当e1就会最大。再看当n为奇数时，分配数组空间为8 n + 24，多出来24字节空间作为e1。e1最大为24，此时s2为16的倍数，且n为奇数。

// 2.当s2不为16的倍数时，p数组空间需要滑动来对齐16，当s2 mod 16=1时，向地址增加方向滑动15个字节，此时达到最大滑动距离了，即e2=15。而e1=可滑动空间-e2，当n为偶数时，滑动空间为16字节，则e1=可滑动空间-e2=16-15=1。e1最小为1，此时s2 mod 16=1，且n为偶数。

// D.这段代码为s2和p的值保证了怎样的对齐属性？

// s2 确保能够容纳足够的p， p能够保证自身16对齐，即保证了数组的起始位置都是16的倍数。